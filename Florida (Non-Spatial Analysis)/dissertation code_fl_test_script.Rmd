---
title: "dissertation code test script"
output:
  pdf_document: default
  html_document: default
---
# Test Script Aims:
1. Computational requirements for small amount of time points vs increased amount
2. Same as above but for increased number of parameters
3. Lack of intensity parameters results in diminished estimates...use of splines improves fit (demonstrate differing dfs)
4. Fine tuning of model specifications gives differing results.....does increasing batch size, max batch size and requested samples give better results in terms of bias/variance? (investigate using best model)
5. If possible use best model to demonstrate different runtimes for exponential distribution vs weibull distribution

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,cache = TRUE)
```

```{r message=FALSE}
library(tidyverse)
library(ABSEIR)
library(splm)
library(openxlsx)
library(optparse)
library(reshape2)
library(lubridate)
library(splines)
library(zoo)
library(imputeTS)
library(plyr)
library(SciViews)
library(forestmangr)
library(matrixStats)
```

```{r}
states <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/rolling-averages/us-states.csv", header = TRUE, sep = ",")

vaccinations <- read.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/vaccinations/us_state_vaccinations.csv", header = TRUE, sep = ",")

census_data <- read.xlsx("https://www2.census.gov/programs-surveys/popest/tables/2010-2019/state/totals/nst-est2019-01.xlsx", startRow = 10, colNames = FALSE)
```

```{r}
fl <- states %>%
  filter(state == "Florida") %>%
  select(., c('date','cases', 'deaths')) %>%
  mutate(weeks = as.numeric(floor(difftime(.$date, as.Date("2020-01-21"), units="weeks")+1)),
         days = as.numeric(floor(difftime(.$date, as.Date("2020-01-21"), units="days")+1)))# adding weeks from date of first recorded cases in us


weeks <- unique(fl$weeks)


vaxx_fl_with_date <- vaccinations %>%
  filter(location == "Florida") %>%
  select(., c('date', 'people_vaccinated','people_fully_vaccinated','total_boosters')) 

vaxx_fl<-na.approx(vaxx_fl_with_date[,-1]) %>% 
     ceiling() %>%
     replace(., is.na(.), 0) %>%
     as.data.frame()

vaccinations_fl <- cbind(vaxx_fl, date = vaxx_fl_with_date$date)

latest_date= tail(na.omit(vaccinations_fl$date),1) # ensures same amount of timepoints as two diff datasets


vaxx_plus_cases_fl <- left_join(fl,vaccinations_fl, by='date') %>%
  filter(date<=latest_date) %>% # filtering to date with latest vaccine info
     replace(., is.na(.), 0) 

vaxx_plus_cases_fl$cases[vaxx_plus_cases_fl$cases == 0] <- NA
vaxx_plus_cases_fl$cases[vaxx_plus_cases_fl$cases < 0] <- NA
vaxx_plus_cases_fl$cases<-na.approx(vaxx_plus_cases_fl$cases) %>% ceiling() # fills in zeroes and negative values with average of two closest values

fl$cases[fl$cases == 0] <- NA
fl$cases[fl$cases < 0] <- NA
fl<-na.trim(fl, "right", is.na = "any") # trim latest rows with null values so can use na.approx
fl$cases<-na.approx(fl$cases) %>% ceiling() # fills in zeroes and negative values with average of two closest values

```


```{r}


first_wave <- fl %>%
  filter(date <= "2020-05-16") # two months after interventions start

second_wave <- fl %>%
  filter(date >= "2021-03-31" & date <= "2021-10-31" )

firstandsecond_wave <- fl %>%
  filter(date <= "2020-08-31" )

third_wave <- fl %>%
  filter(date >= "2021-07-12")

vaccines_dates <- vaxx_plus_cases_fl %>%
  filter(date>="2021-11-01" & date <= "2022-03-01")


```



```{r data, echo=TRUE, eval=TRUE}


data_model = DataModel(Y=first_wave$cases, 
                             type = "identity",      
                             compartment = "I_star", # data related to new infections
                             cumulative = FALSE       # not reported on cumulative scale
                             )

data_model_interventions = DataModel(Y=firstandsecond_wave$cases, 
                             type = "identity",      
                             compartment = "I_star", 
                             cumulative = FALSE       
                             )


data_model_vaccines = DataModel(Y=vaccines_dates$cases, 
                             type = "identity",      
                             compartment = "I_star", 
                             cumulative = FALSE       
                             )

```

```{r exposure, echo=TRUE, eval=TRUE}

# https://ballotpedia.org/Government_responses_to_and_political_effects_of_the_coronavirus_pandemic,_2020_(Florida)#Statewide_stay-at-home_order.2C_March_23_through_December_4  [saho date and expiry]

# https://ballotpedia.org/Documenting_Florida%27s_path_to_recovery_from_the_coronavirus_(COVID-19)_pandemic,_2020-2021#School_reopenings_and_closures      [first intervention date]

exposure_model_1 = ExposureModel(matrix(1, nrow = nrow(first_wave)),
                                nTpt = nrow(first_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,  # prior precision = 1/var...N(0,2) 
                                                            # small variance aids in analysing intervention effects
                                betaPriorMean = 0)

intervention_term_1 = cumsum(first_wave$date >=  as.Date("2020-03-16", "%Y-%m-%d"))/10 # statewide school closure
intervention_term_2 = cumsum(first_wave$date >=  as.Date("2020-04-02", "%Y-%m-%d"))/10 # statewide stay @ home order

exposure_model_2 = ExposureModel(cbind(1,intervention_term_1),
                                nTpt = nrow(first_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_3 = ExposureModel(cbind(1,intervention_term_1, intervention_term_2),
                                nTpt = nrow(first_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)


# tweak prior precision? "To allow the potential for the intervention to have a strong effect the prior on $\beta_2$ has a large variance"
# S -> E is governed by exposure rate/epidemic intensity which in turn drives infections (E -> I)
# formulating this process in terms of a linear predictor offers an intuitive and flexible way to incorporate changes in epidemic intensity over the course of the time period, which allows transmission to increase or decrease over time
# a common model of transmission considers constant transmission until the introduction of control measures, after which transmission decays exponentially (e.g. Lekone and Finkenstadt (2006)
```

```{r}

intervention_term_1a = cumsum(firstandsecond_wave$date >=  as.Date("2020-03-16", "%Y-%m-%d"))/10 # statewide school closure
intervention_term_2a = cumsum(firstandsecond_wave$date >=  as.Date("2020-04-02", "%Y-%m-%d"))/10 # statewide stay @ home order 

# dividing by 10 (scaling) effect of intervention term improves estimation in terms of the two wave case (at least when splines are added); this ensures that the effect of the intervention does not shrink the epidemic intensity to the point where the epidemic dies out, this of which is not the case with covid (multiple waves)

exposure_model_4 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a), # no
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

```


```{r}

time_basis_df_3 = bs(1:nrow(firstandsecond_wave), df = 3)[rep(1:nrow(firstandsecond_wave), 1),] 
time_basis_df_4 = bs(1:nrow(firstandsecond_wave), df = 4)[rep(1:nrow(firstandsecond_wave), 1),] 
time_basis_df_5 = bs(1:nrow(firstandsecond_wave), df = 5)[rep(1:nrow(firstandsecond_wave), 1),] 
time_basis_df_6 = bs(1:nrow(firstandsecond_wave), df = 6)[rep(1:nrow(firstandsecond_wave), 1),] 


exposure_model_5 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_3), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_6 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_4), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_7 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_5), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_8 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_6), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)


```

```{r}

reopen_date = cumsum(firstandsecond_wave$date >=  as.Date("2020-05-04", "%Y-%m-%d"))/10 # expiration of saho; also allowed restaurants, retail stores, libraries, and museums to open to 25% of their building occupancy under certain guidelines

X_seasonal <- cbind(1, 
                    sin(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)), 
                    cos(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)), 
                    cos(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)) *sin(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)))




exposure_model_9 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 1)

exposure_model_10 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_3), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_11 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_4), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_12 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_5), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_13 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_6), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)


exposure_model_14 = ExposureModel(cbind(X_seasonal, intervention_term_1a, intervention_term_2a, reopen_date), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

```




```{r}
latest_vaxxed = head(vaccines_dates$people_vaccinated,1) # at least one vaccine; does not include counts for second dose
latest_fully_vaxxed = head(vaccines_dates$people_fully_vaccinated,1)  # counts for first and second doses
latest_boosted = head(vaccines_dates$total_boosters,1)# only those with boosters



time_basis_vaccines = bs(1:nrow(vaccines_dates), degree = 4)[rep(1:nrow(vaccines_dates), 1),]

X_vaccines <- cbind(1, 
                    sin(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)), 
                    cos(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)), 
                    cos(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)) *sin(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)))


vaccine_prop <- data.frame(prop_vaxxed = latest_vaxxed/21477737,
                                        prop_fully_vaxxed = latest_fully_vaxxed/21477737)


exposure.design.matrix <- as.matrix(
                            cbind(1,
                                  X_vaccines,
                                  #time_basis_vaccines,
                              vaccine_prop
                            )
                          )


exposure_model_15 = ExposureModel(exposure.design.matrix,
                                      nTpt = nrow(vaccines_dates),
                                      nLoc = 1,
                                      betaPriorPrecision = 0.5,
                                      betaPriorMean = 0)


#  "A minimally informative beta prior, beta(0.700102, 1), is proposed for θ = (1-VE)/(2-VE). The prior is centered at θ = 0.4118 (VE=30%) which can be considered pessimistic. The prior allows considerable uncertainty"
```




```{r}


initial_values = InitialValueContainer(S0 = 21477737, 
                                             E0 = 2,
                                             I0 = 2,
                                             R0 = 0)
```

```{r}

removed_estimate = vaxx_plus_cases_fl %>% 
  filter(date<="2021-11-01") %>% 
  summarise(sum(cases)) * 1-exp(-1/16) * 6

deaths_only_estimate = vaxx_plus_cases_fl %>% 
  filter(date<="2021-11-01") %>% 
  summarise(sum(deaths))



initial_values_vaccines = InitialValueContainer(S0 = 21477737-1e3-head(vaccines_dates$cases,1)-deaths_only_estimate, 
                                             E0 = 1e3,
                                             I0 = head(vaccines_dates$cases,1),
                                             R0 = deaths_only_estimate)
```

```{r reinfection, echo=TRUE, eval=TRUE}

reinfection_model = ReinfectionModel("SEIR") # without reinfection rate

```


```{r distance, echo=TRUE, eval=TRUE}

distance_model = DistanceModel(list(matrix(0))) # considering as one state therefore initialising with empty matrix

```

```{r}
# reference: https://github.com/grantbrown/COVID19-US/blob/master/Templates/default.template.mortality.R

# Model to describe E to I and I to R transition probabilities.

# Latent period: 2-14 days with median 5

# find proper reference supporting this info  ^^

pickWeibullPars <- function(qdf){
  rslt <- optim(par = c(1,1), fn = function(par){
    sum((qweibull(p = qdf$q, shape = par[1], scale = par[2]) - qdf$x)^2)
  })
  rslt$par
}

pickGammaHyperPars <- function(mean, ESS){
  b <- ESS/(mean+1)     # ESS = effective sample size
  a <- ESS - b          # b = event occur rate and a = number of events occurred
  c(a,b)
}

latent_par_means <- pickWeibullPars(qdf=data.frame(q=c(0.025,0.5,0.975),
                                                   x=c(2,5,12)))
infectious_par_means <- pickWeibullPars(qdf = data.frame(q=c(0.025,0.5,0.975),
                                                         x = c(8,13,22)))

weibull_transition_priors <- WeibullTransitionPriors(latent_shape_prior_alpha = pickGammaHyperPars(latent_par_means[1], 1000)[1],
                                            latent_shape_prior_beta = pickGammaHyperPars(latent_par_means[1], 1000)[2],
                                            latent_scale_prior_alpha = pickGammaHyperPars(latent_par_means[2], 1000)[1],
                                            latent_scale_prior_beta = pickGammaHyperPars(latent_par_means[2], 1000)[2],
                                            infectious_shape_prior_alpha = pickGammaHyperPars(infectious_par_means[1], 100)[1], #less certain about infectious period...in other words we have a larger range in which one can be infectious when compared to small latent period range so we use a smaller ESS
                                            infectious_shape_prior_beta = pickGammaHyperPars(infectious_par_means[1], 100)[2],
                                            infectious_scale_prior_alpha = pickGammaHyperPars(infectious_par_means[2], 100)[1],
                                            infectious_scale_prior_beta = pickGammaHyperPars(infectious_par_means[2], 100)[2])
```

```{r}

weibull_alpha_latent = qgamma(0.1, weibull_transition_priors$latent_shape_prior_alpha,
                        weibull_transition_priors$latent_shape_prior_beta) #minEIShape
 
weibull_beta_latent = qgamma(0.9, weibull_transition_priors$latent_scale_prior_alpha,
                        weibull_transition_priors$latent_scale_prior_beta) #maxEIScale

weibull_alpha_infectious = qgamma(0.1, weibull_transition_priors$infectious_shape_prior_alpha,
                        weibull_transition_priors$infectious_shape_prior_beta) #minIRShape
 
weibull_beta_infectious = qgamma(0.9, weibull_transition_priors$infectious_scale_prior_alpha,
                        weibull_transition_priors$infectious_scale_prior_beta) #maxIRScale

pweibull(10, shape = weibull_alpha_latent, scale = weibull_beta_latent) # (prior) probability individual will transition from exposed to infectious within 10 days

pweibull(14, shape = weibull_alpha_infectious, scale = weibull_beta_infectious) # (prior) probability individual will transition from infectious to removed within two weeks

weibull_beta_latent * gamma(1 + 1/weibull_alpha_latent) # mean latent period
weibull_beta_infectious * gamma(1 + 1/weibull_alpha_infectious) # mean infectious period

weibull_beta_latent*(ln(2))^(1/weibull_alpha_latent) # median latent period
weibull_beta_infectious*(ln(2))^(1/weibull_alpha_infectious) # median infectious period


#sqrt((scale^2) * (gamma(1 + 2/shape) - gamma(1 + 1/shape)^2)) # sd
```

```{r}
curve(dweibull(x, shape=weibull_alpha_latent, scale = weibull_beta_latent), from=0, to=22, xlab = "Days", ylab = "Probability")
```

```{r}
curve(dweibull(x, shape=weibull_alpha_infectious, scale = weibull_beta_infectious), from=0, to=35,xlab = "Days", ylab = "Probability")
```

```{r}
exp_transition_priors = ExponentialTransitionPriors(p_ei = 1-exp(-1/6),    # cdf of exponential dist...dont have actual value of gamma so estimate 
                                                    p_ir= 1-exp(-1/16),    # using mean (gamma) = 1/days......exp(rate parameter = 1/6)
                                                    p_ei_ess = 1000,        # more informative as 1000 > 100
                                                    p_ir_ess = 100)
  # 1-exp(-gamma) = p_ei is transition prob and 1/gamma is the mean period


# use best three models for each differing timelines...one that gives closest estimate to provided mean periods = run with weibull for comparison
```


```{r sampling control, echo=TRUE, eval=TRUE}

# shrinkage: improves prediction because of the bias-variance tradeoff; a small increase in bias (the penalty) in exchange for a larger reduction in variance (the model is less sensitive to noise or correlation of predictors)
# shrinkage estimation deliberately increases the bias of the model in order to reduce variance and improve overall model performance, often at the cost of individual estimates
# less shrinkage = less bias but more variance

# from documentation: shrinkage defines the multiplicative constant by which the maximum distance between simulated and observed epidemics is shrunk between each iteration.....(simulated values shrunk closer towards observed values after each iteration)

# shrinkage x previous epsilon = current epsilon

sampling_control_SMC = SamplingControl(seed = 123123, 
                                    n_cores = 14,
                                    algorithm="Beaumont2009",
                                    list(batch_size = 2000,
                                         init_batch_size = 1000000,
                                         epochs = 1e6,
                                         max_batches = 250, 
                                         shrinkage = 0.99, # 1.5 bias for 0.9, higher for 0.999
                                         multivariate_perturbation=FALSE,
                                         keep_compartments = TRUE
                                    )
 )

sampling_control_basic = SamplingControl(seed = 123123, 
                                    n_cores = 14,
                                    algorithm="BasicABC",
                                    list(batch_size = 2000,
                                         #init_batch_size = 1000000,
                                         epochs = 1e6,
                                         max_batches = 200,
                                         shrinkage = 0.85,
                                         multivariate_perturbation=FALSE,
                                         keep_compartments = TRUE
                                    )
 )

# Initial sampling step: simulate 100k epidemics from prior. 
sampling_control.init <- SamplingControl(seed=123123,
                                               n_cores = 16,
                                               algorithm = "Beaumont2009",
                                               params = list(
                                                  batch_size = 500000,
                                                  epochs = 1,
                                                  shrinkage = 0.98,
                                                  max_batches = 1,
                                                  multivariate_perturbation=FALSE
                                              ))
# SMC Sampling configuration
sampling_control_update <- SamplingControl(seed=123126,
                                          n_cores = 14,
                                          algorithm = "Beaumont2009",
                                          params = list(
                                            batch_size = 5000,
                                            epochs = 1e6,
                                            shrinkage = 0.99,
                                            max_batches = 1000,
                                            multivariate_perturbation=FALSE
                                          )) 
# algorithm="Beaumont2009" for SMC-ABC
```

```{r runtime and summary, cache=TRUE}

#consider showing difference of weibull transition priors vs exponential transition priors
#get results for basic ABC for exp and weibull both SMC and basic


runtime1 = system.time(result1 <- SpatialSEIRModel(data_model,
                                                    exposure_model_1,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime2 = system.time(result2 <- SpatialSEIRModel(data_model,
                                                    exposure_model_2,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime3 = system.time(result3 <- SpatialSEIRModel(data_model,
                                                    exposure_model_3,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
```


```{r,cache=TRUE}

runtime4 = system.time(result4 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_4,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100, # less samples, less variance
                                                    verbose = 2))
runtime5 = system.time(result5 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_5,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime6 = system.time(result6 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_6,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime7 = system.time(result7 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_7,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime8 = system.time(result8 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_8,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))

```

```{r,cache=TRUE}

runtime9 = system.time(result9 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_9,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime10 = system.time(result10 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_10,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime11 = system.time(result11 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_11,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime12 = system.time(result12 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_12,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime13 = system.time(result13 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_13,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime14 = system.time(result14 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_14,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
# Interpretation of Beta_SE coefficients: https://github.com/grantbrown/ABSEIR/issues/17

```

```{r,cache=TRUE}
runtime15 = system.time(result15 <- SpatialSEIRModel(data_model_vaccines,
                                                    exposure_model_15,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values_vaccines,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))



```


```{r}
compareModels(list(result2, result3), n_samples = 1000, 
              batch_size = 2000)

# splines approach allows us to construct fexible models in the absence of structural information about the pandemic which would otherwise help inform the intensity process, such as finer spatiotemporal indexing (ie. between counties) and comprehensive data on public health efforts, among other things.....especially with florida as they never had any state mandated mask wearing protocols but this doesnt mean individuals didnt take part in mask wearing (which reduces exposure)

# If these (current eps) are dramatically different, this approach may produce misleading results.

```
```{r}
compareModels(list(result4, result5, result6, result7, result8), n_samples = 1000, 
              batch_size = 2000)

# model 6 best
```
```{r}
compareModels(list(result9, result10, result11, result12, result13, result14), n_samples = 1000, 
              batch_size = 2000)

# model 11 best
```


```{r,cache=TRUE}
simulations1 <- epidemic.simulations(result1, replicates = 50)
simulations2 <- epidemic.simulations(result2, replicates = 50)
simulations3 <- epidemic.simulations(result3, replicates = 50)
```

```{r,cache=TRUE}
simulations4 <- epidemic.simulations(result4, replicates = 50)
simulations5 <- epidemic.simulations(result5, replicates = 50)
simulations6 <- epidemic.simulations(result6, replicates = 50)
simulations7 <- epidemic.simulations(result7, replicates = 50)
simulations8 <- epidemic.simulations(result8, replicates = 50)

```

```{r,cache=TRUE}
simulations9 <- epidemic.simulations(result9, replicates = 50)
simulations10 <- epidemic.simulations(result10, replicates = 50)
simulations11 <- epidemic.simulations(result11, replicates = 50)
simulations12 <- epidemic.simulations(result12, replicates = 50)
simulations13 <- epidemic.simulations(result13, replicates = 50)
simulations14 <- epidemic.simulations(result14, replicates = 50)

```

```{r,cache=TRUE}
simulations15 <- epidemic.simulations(result15, replicates = 50)

```




```{r}
get_coverage_ei = function(simulations, true_params)  
{
  allSimulatedlatent = sapply(simulations$simulationResults, function(x){x$p_ei})
  
  lowerQuantile = apply(allSimulatedlatent, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedlatent, 1, mean)
  upperQuantile = apply(allSimulatedlatent, 1, quantile, probs = c(0.975))

    
  
  a = mean(lowerQuantile <= true_params & true_params <= upperQuantile ) # should be column of quantiles
  
  b = mean(upperQuantile - lowerQuantile)
  
  c = bias_per(y = true_params, yhat = posteriorMean)
  
  return(list(coverage=a, width=b, bias=c))

}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
get_coverage_ir = function(simulations, true_params)  
{
  allSimulatedinfectious = sapply(simulations$simulationResults, function(x){x$p_ir})
  
  lowerQuantile = apply(allSimulatedinfectious, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedinfectious, 1, mean)
  upperQuantile = apply(allSimulatedinfectious, 1, quantile, probs = c(0.975))

    
  
  a = mean(lowerQuantile <= true_params & true_params <= upperQuantile ) # should be column of quantiles
  
  b = mean(upperQuantile - lowerQuantile)
  
  c = bias_per(y = true_params, yhat = posteriorMean)
  
  return(list(coverage=a, width=b, bias=c))

}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
plotPosteriorPredictive_firstwave = function(simulations, main)  
{
  allSimulatedI_star = sapply(simulations$simulationResults, function(x){x$I_star})
  
  lowerQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedI_star, 1, mean)
  upperQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.975))
  
  
  plot(first_wave$cases, ylim = c(0, max(upperQuantile)),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  lines(upperQuantile, lty = 2, col = "blue")
  lines(lowerQuantile, lty = 2, col = "blue")
  lines(posteriorMean, lty = 1, col = "blue")
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed"), lty = c(1,2,0), 
         pch = c(NA,NA,1), col = c("blue", "blue", "black"), cex = 1)
}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
plotPosteriorPredictive_interventions = function(simulations, main)  
{
  allSimulatedI_star = sapply(simulations$simulationResults, function(x){x$I_star})
  
  lowerQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedI_star, 1, mean)
  upperQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.975))
  
  
  plot(firstandsecond_wave$cases, ylim = c(0, max(posteriorMean)*1.75),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  lines(upperQuantile, lty = 2, col = "blue")
  lines(lowerQuantile, lty = 2, col = "blue")
  lines(posteriorMean, lty = 1, col = "blue")
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed"), lty = c(1,2,0), 
         pch = c(NA,NA,1), col = c("blue", "blue", "black"), cex = 1)
}

```

```{r}
plotPosteriorPredictive_vaccines = function(simulations, main)
{
  allSimulatedI_star = sapply(simulations$simulationResults, function(x){x$I_star})
  
  lowerQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedI_star, 1, mean)
  upperQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.975))
  
  
  plot(vaccines_dates$cases, ylim = c(0, max(vaccines_dates$cases)),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  lines(upperQuantile, lty = 2, col = "blue")
  lines(lowerQuantile, lty = 2, col = "blue")
  lines(posteriorMean, lty = 1, col = "blue")
  
  #legend("topleft", legend = c("Mean", "95% CI", "Observed"), lty = c(1,2,0), 
         #pch = c(NA,NA,1), col = c("blue", "blue", "black"), cex = 1)
}

```


```{r}
plotPosteriorPredictive_firstwave(simulations1, "Model 1: Posterior Predictive Distribution")
plotPosteriorPredictive_firstwave(result1, "Model 1: Posterior Distribution")
```


```{r}
plotPosteriorPredictive_firstwave(simulations2, "Model 2: Posterior Predictive Distribution")
plotPosteriorPredictive_firstwave(result2, "Model 2: Posterior Distribution")
# interventions start at day 35
# assumes constant transmission until the introduction of control measures afterwhich transmission decays...hence why we see the model predict a peak around day 40-45 and decreases afterwards
```

```{r}
plotPosteriorPredictive_firstwave(simulations3, "Model 3: Posterior Predictive Distribution")
plotPosteriorPredictive_firstwave(result3, "Model 3: Posterior Distribution")
```

```{r}
plotPosteriorPredictive_interventions(simulations4, "Model 4: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result4, "Model 4: Posterior Distribution")

# two interventions
```
```{r}
plotPosteriorPredictive_interventions(simulations5, "Model 5: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result5, "Model 5: Posterior Distribution")

# two interventions plus time basis of 3
```
```{r}
plotPosteriorPredictive_interventions(simulations6, "Model 6: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result6, "Model 6: Posterior Distribution")

# two interventions plus time basis of 4
```
```{r}
plotPosteriorPredictive_interventions(simulations7, "Model 7: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result7, "Model 7: Posterior Distribution")

# two interventions plus time basis of 5
```
```{r}
plotPosteriorPredictive_interventions(simulations8, "Model 8: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result8, "Model 8: Posterior Distribution")

# two interventions plus time basis of 6
```
```{r}
plotPosteriorPredictive_interventions(simulations9, "Model 9: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result9, "Model 9: Posterior Distribution")

# two interventions and reopen
```

```{r}
plotPosteriorPredictive_interventions(simulations10, "Model 10: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result10, "Model 10: Posterior Distribution")

# two interventions, reopen and time basis of 3
```

```{r}
plotPosteriorPredictive_interventions(simulations11, "Model 11: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result11, "Model 11: Posterior Distribution")

# two interventions, reopen and time basis of 4
```

```{r}
plotPosteriorPredictive_interventions(simulations12, "Model 12: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result12, "Model 12: Posterior Distribution")

# two interventions, reopen and time basis of 5
```

```{r}
plotPosteriorPredictive_interventions(simulations13, "Model 13: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result13, "Model 13: Posterior Distribution")

# two interventions, reopen and time basis of 5
```

```{r}
plotPosteriorPredictive_interventions(simulations14, "Model 14: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result14, "Model 14: Posterior Distribution")

# two interventions, reopen and time basis of 6
```

```{r}
plotPosteriorPredictive_vaccines(simulations15, "Model 15: Posterior Predictive Distribution")
plotPosteriorPredictive_vaccines(result15, "Model 15: Posterior Distribution")

# use vaccines for spatial case only
```

```{r}
beta_idx_m3 <- grepl("Beta_SE", colnames(result3$param.samples)) # use to get beta estimates/samples
eta_m3 <- exposure_model_3$X %*% t(result3$param.samples[,beta_idx_m3]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m3, 1, mean), 
      type = 'l', 
      main = 'Model 3 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day')
 
 # drives the I_star compartment
```

```{r}

beta_idx_m6 <- grepl("Beta_SE", colnames(result6$param.samples)) # use to get beta estimates/samples
eta_m6 <- exposure_model_6$X %*% t(result6$param.samples[,beta_idx_m6]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m6, 1, mean), 
      type = 'l', 
      main = 'Model 6 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day')
 
 # drives the I_star compartment
```
```{r}

beta_idx_m11 <- grepl("Beta_SE", colnames(result11$param.samples)) # use to get beta estimates/samples
eta_m11 <- exposure_model_11$X %*% t(result11$param.samples[,beta_idx_m11]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m11, 1, mean), 
      type = 'l', 
      main = 'Model 11 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day')
 
 # drives the I_star compartment
```

```{r}
summary(result1)

```
```{r}
summary(result2)
```
```{r}
summary(result3)

# effect of first intervention is stronger than that of the stay at home order in terms of flattening curve
# ideally cases should decrease after second intervention however they stay at a constant rate/number hence the position beta se estsimate for saho
# in fact this timeline overlaps with the reopen date/end of saho.....this is what is possibly (?) masking the effect of the saho such that the intensity appears to increase but actually this increas is due to the reopening
```
```{r}
summary(result4)
```
```{r}
summary(result5)
```
```{r}
summary(result6)
```

```{r}
summary(result7)
```
```{r}
summary(result8)
```
```{r}
summary(result9)
```
```{r}
summary(result10)
```
```{r}
summary(result11)
```
```{r}
summary(result12)
```
```{r}
summary(result13)
```
```{r}
summary(result14)
```
```{r}
summary(result15)
```


```{r}
compareModels(list(result6, result11), n_samples = 1000, 
              batch_size = 2000)


```
```{r}
get_coverage_ei(simulations6, exp_transition_priors$p_ei) # underestimates latent period (minuscule)
```
```{r}
get_coverage_ei(simulations11, exp_transition_priors$p_ei) # underestimates latent period (minuscule)
```

```{r}
get_coverage_ir(simulations6, exp_transition_priors$p_ir)  # increased bias magnitude due to less confidence in terms of prior infectious period...slightly overestimates infectious period
```
```{r}
get_coverage_ir(simulations11, exp_transition_priors$p_ir)

# overestimates infectious period.....increased positive bias
```
```{r,cache=TRUE}
runtime6_weibull = system.time(result6_weibull <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_6,
                                                    reinfection_model,
                                                    distance_model,
                                                   weibull_transition_priors,
                                                    #exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
```

```{r,cache=TRUE}
simulations6_weibull <- epidemic.simulations(result6_weibull, replicates = 50)

```

```{r}
summary(result6_weibull)
```
```{r}
compareModels(list(result6, result6_weibull), n_samples = 1000, 
              batch_size = 2000)

# weibull better
```

```{r}
get_coverage_weibull = function(simulations, true_params, column)  
{
  sims <- as.data.frame(t(simulations$params[,column]))
  sims <- do.call("rbind", replicate(nrow(firstandsecond_wave), sims, simplify = FALSE))

  lowerQuantile = apply(sims, 1, quantile, probs = c(0.025))
  posteriorMean = apply(sims, 1, mean)
  upperQuantile = apply(sims, 1, quantile, probs = c(0.975))

    
  
  a = mean(lowerQuantile <= true_params & true_params <= upperQuantile ) # should be column of quantiles
  
  b = mean(upperQuantile - lowerQuantile)
  
  c = sum(mean(posteriorMean) - true_params)/sum(true_params) * 100
  
  return(list(coverage=a, width=b, bias=c))

}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
get_coverage_weibull(simulations6_weibull,weibull_alpha_latent,"latent_shape")
```
```{r}
get_coverage_weibull(simulations6_weibull,weibull_beta_latent,"latent_scale")
```

```{r}
get_coverage_weibull(simulations6_weibull,weibull_alpha_infectious,"infectious_shape")
```

```{r}
get_coverage_weibull(simulations6_weibull,weibull_beta_infectious,"infectious_scale")
```

```{r}
timeMatrix = rbind(runtime1,runtime2, runtime3, runtime4, runtime5, runtime6, runtime7, runtime8, runtime9, runtime10, runtime11,
                   runtime12, runtime13, runtime14, runtime15, runtime6_weibull)
rownames(timeMatrix) = paste("model", 1:16)
print(timeMatrix[,1:3])
# use in table with number of parameters and also number of timepoints
```








