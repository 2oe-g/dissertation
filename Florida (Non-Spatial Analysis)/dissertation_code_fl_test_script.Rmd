---
title: "dissertation code test script"
output:
  pdf_document: default
  html_document: default
---
# Test Script Aims:
1. Computational requirements for small amount of time points vs increased amount
2. Same as above but for increased number of parameters
3. Lack of intensity parameters results in diminished estimates...use of splines improves fit (demonstrate differing dfs)
4. Fine tuning of model specifications gives differing results.....does increasing batch size, max batch size and requested samples give better results in terms of bias/variance? (investigate using best model)
5. If possible use best model to demonstrate different runtimes for exponential distribution vs weibull distribution
6. Use SMC-ABC to first derive working/acceptable models since this algorithm is expected to improve approximation efficiency when compared to basic ABC (when the prior(s) is diffuse to the posterior); also some package functionality such as Bayes factor derivation is only limited to simulations using SMC-ABC algorithm. Then for best model(s), using basic ABC to see if there is a significant different in results...in real world situations where prior info may not be well-known/established, SMC-ABC would clearly be more efficient, however in this analysis we use relatively informative priors (especially in terms of latent and infectious periods) so the difference between the basic algorithm and the SMC one may not be that significant!

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

1. Load necessary libraries

```{r message=FALSE}

library(tidyverse)
library(ABSEIR)
library(splm)
library(openxlsx)
library(optparse)
library(reshape2)
library(lubridate)
library(splines)
library(zoo)
library(imputeTS)
library(plyr)
library(SciViews)
library(forestmangr)
library(matrixStats)
```

2. Load necessary data

```{r}
states <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/rolling-averages/us-states.csv", header = TRUE, sep = ",")

vaccinations <- read.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/vaccinations/us_state_vaccinations.csv", header = TRUE, sep = ",")

census_data <- read.xlsx("https://www2.census.gov/programs-surveys/popest/tables/2010-2019/state/totals/nst-est2019-01.xlsx", startRow = 10, colNames = FALSE)
```

3. Data cleaning

```{r}
fl <- states %>%
  filter(state == "Florida") %>%
  select(., c('date','cases', 'deaths')) %>%
  mutate(weeks = as.numeric(floor(difftime(.$date, as.Date("2020-01-21"), units="weeks")+1)),
         days = as.numeric(floor(difftime(.$date, as.Date("2020-01-21"), units="days")+1)))# adding weeks from date of first recorded cases in us


weeks <- unique(fl$weeks)


vaxx_fl_with_date <- vaccinations %>%
  filter(location == "Florida") %>%
  select(., c('date', 'people_vaccinated','people_fully_vaccinated','total_boosters')) 

vaxx_fl<-na.approx(vaxx_fl_with_date[,-1]) %>% 
     ceiling() %>%
     replace(., is.na(.), 0) %>%
     as.data.frame()

vaccinations_fl <- cbind(vaxx_fl, date = vaxx_fl_with_date$date)

latest_date= tail(na.omit(vaccinations_fl$date),1) # ensures same amount of timepoints as two diff datasets


vaxx_plus_cases_fl <- left_join(fl,vaccinations_fl, by='date') %>%
  filter(date<=latest_date) %>% # filtering to date with latest vaccine info
     replace(., is.na(.), 0) 

vaxx_plus_cases_fl$cases[vaxx_plus_cases_fl$cases == 0] <- NA
vaxx_plus_cases_fl$cases[vaxx_plus_cases_fl$cases < 0] <- NA
vaxx_plus_cases_fl$cases<-na.approx(vaxx_plus_cases_fl$cases) %>% ceiling() # fills in zeroes and negative values with average of two closest values

fl$cases[fl$cases == 0] <- NA
fl$cases[fl$cases < 0] <- NA
fl<-na.trim(fl, "right", is.na = "any") # trim latest rows with null values so can use na.approx
fl$cases<-na.approx(fl$cases) %>% ceiling() # fills in zeroes and negative values with average of two closest values

```

4. Filter data by dates for analysis

```{r}


first_wave <- fl %>%
  filter(date <= "2020-05-16") # two months after interventions start

second_wave <- fl %>%
  filter(date >= "2021-03-31" & date <= "2021-10-31" )

firstandsecond_wave <- fl %>%
  filter(date <= "2020-08-31" )

third_wave <- fl %>%
  filter(date >= "2021-07-12")

vaccines_dates <- vaxx_plus_cases_fl %>%
  filter(date>="2021-11-01" & date <= "2022-03-01")


```

5. Use filtered data for respective data models 

```{r data, echo=TRUE, eval=TRUE}


data_model = DataModel(Y=first_wave$cases, 
                             type = "identity",      
                             compartment = "I_star", # data related to new infections
                             cumulative = FALSE       # not reported on cumulative scale
                             )

data_model_interventions = DataModel(Y=firstandsecond_wave$cases, 
                             type = "identity",      
                             compartment = "I_star", 
                             cumulative = FALSE       
                             )


data_model_vaccines = DataModel(Y=vaccines_dates$cases, 
                             type = "identity",      
                             compartment = "I_star", 
                             cumulative = FALSE       
                             )

```

6. Set up exposure model for first wave; unconstrained epidemic growth vs one intervention vs two interventions

```{r exposure, echo=TRUE, eval=TRUE}

# https://ballotpedia.org/Government_responses_to_and_political_effects_of_the_coronavirus_pandemic,_2020_(Florida)#Statewide_stay-at-home_order.2C_March_23_through_December_4  [saho date and expiry]

# https://ballotpedia.org/Documenting_Florida%27s_path_to_recovery_from_the_coronavirus_(COVID-19)_pandemic,_2020-2021#School_reopenings_and_closures      [first intervention date]

exposure_model_1 = ExposureModel(matrix(1, nrow = nrow(first_wave)),
                                nTpt = nrow(first_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,  # prior precision = 1/var...N(0,2) 
                                                            # small variance aids in analysing intervention effects
                                betaPriorMean = 0)

intervention_term_1 = cumsum(first_wave$date >=  as.Date("2020-03-16", "%Y-%m-%d"))/10 # statewide school closure
intervention_term_2 = cumsum(first_wave$date >=  as.Date("2020-04-02", "%Y-%m-%d"))/10 # statewide stay @ home order

exposure_model_2 = ExposureModel(cbind(1,intervention_term_1),
                                nTpt = nrow(first_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_3 = ExposureModel(cbind(1,intervention_term_1, intervention_term_2),
                                nTpt = nrow(first_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)


# tweak prior precision? "To allow the potential for the intervention to have a strong effect the prior on $\beta_2$ has a large variance"
# S -> E is governed by exposure rate/epidemic intensity which in turn drives infections (E -> I)
# formulating this process in terms of a linear predictor offers an intuitive and flexible way to incorporate changes in epidemic intensity over the course of the time period, which allows transmission to increase or decrease over time
# a common model of transmission considers constant transmission until the introduction of control measures, after which transmission decays exponentially (e.g. Lekone and Finkenstadt (2006)
```

7. Extend timeline to two waves; two interventions
```{r}

intervention_term_1a = cumsum(firstandsecond_wave$date >=  as.Date("2020-03-16", "%Y-%m-%d"))/10 # statewide school closure
intervention_term_2a = cumsum(firstandsecond_wave$date >=  as.Date("2020-04-02", "%Y-%m-%d"))/10 # statewide stay @ home order 

# dividing by 10 (scaling) effect of intervention term improves estimation in terms of the two wave case (at least when splines are added); this ensures that the effect of the intervention does not shrink the epidemic intensity to the point where the epidemic dies out, this of which is not the case with covid (multiple waves)

exposure_model_4 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a), # no
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

```

8. Two waves; improve fit by trying different spline dfs

```{r}

time_basis_df_3 = bs(1:nrow(firstandsecond_wave), df = 3)[rep(1:nrow(firstandsecond_wave), 1),] 
time_basis_df_4 = bs(1:nrow(firstandsecond_wave), df = 4)[rep(1:nrow(firstandsecond_wave), 1),] 
time_basis_df_5 = bs(1:nrow(firstandsecond_wave), df = 5)[rep(1:nrow(firstandsecond_wave), 1),] 
time_basis_df_6 = bs(1:nrow(firstandsecond_wave), df = 6)[rep(1:nrow(firstandsecond_wave), 1),] 


exposure_model_5 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_3), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_6 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_4), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_7 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_5), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_8 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a, time_basis_df_6), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)


```

9. Two waves; two interventions + reopen term; try to improve fit with different spline dfs and trigonometric temporal term

```{r}

reopen_date = cumsum(firstandsecond_wave$date >=  as.Date("2020-05-04", "%Y-%m-%d"))/10 # expiration of saho; also allowed restaurants, retail stores, libraries, and museums to open to 25% of their building occupancy under certain guidelines

X_seasonal <- cbind(1, 
                    sin(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)), 
                    cos(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)), 
                    cos(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)) *sin(2*pi*1:length(firstandsecond_wave$days)/length(firstandsecond_wave$days)))




exposure_model_9 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

exposure_model_10 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_3), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_11 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_4), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_12 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_5), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)
exposure_model_13 = ExposureModel(cbind(1,intervention_term_1a, intervention_term_2a,reopen_date, time_basis_df_6), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)


exposure_model_14 = ExposureModel(cbind(X_seasonal, intervention_term_1a, intervention_term_2a, reopen_date), # decent
                                nTpt = nrow(firstandsecond_wave),
                                nLoc = 1,
                                betaPriorPrecision = 0.5,
                                betaPriorMean = 0)

```

10. Timeline starting from 2022; add vaccine data to see its effect on exposure/intensity rate; trigonometric temporal term

```{r}
latest_vaxxed = head(vaccines_dates$people_vaccinated,1) # at least one vaccine; does not include counts for second dose
latest_fully_vaxxed = head(vaccines_dates$people_fully_vaccinated,1)  # counts for first and second doses
latest_boosted = head(vaccines_dates$total_boosters,1)# only those with boosters



time_basis_vaccines = bs(1:nrow(vaccines_dates), degree = 4)[rep(1:nrow(vaccines_dates), 1),]

X_vaccines <- cbind(1, 
                    sin(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)), 
                    cos(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)), 
                    cos(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)) *sin(2*pi*1:nrow(vaccines_dates)/nrow(vaccines_dates)))


vaccine_prop <- data.frame(prop_vaxxed = latest_vaxxed/21477737,
                                        prop_fully_vaxxed = latest_fully_vaxxed/21477737)


exposure.design.matrix <- as.matrix(
                            cbind(1,
                                  X_vaccines,
                                  #time_basis_vaccines,
                              vaccine_prop
                            )
                          )


exposure_model_15 = ExposureModel(exposure.design.matrix,
                                      nTpt = nrow(vaccines_dates),
                                      nLoc = 1,
                                      betaPriorPrecision = 0.5,
                                      betaPriorMean = 0)


#  "A minimally informative beta prior, beta(0.700102, 1), is proposed for θ = (1-VE)/(2-VE). The prior is centered at θ = 0.4118 (VE=30%) which can be considered pessimistic. The prior allows considerable uncertainty"
```

11. Initial values (population, starting number of exposed, infected and removed)

```{r}


initial_values = InitialValueContainer(S0 = 21477737, 
                                             E0 = 2,
                                             I0 = 2,
                                             R0 = 0)
```

12. Initial values starting from 2022 (population, starting number of exposed, infected and removed)

```{r}

removed_estimate = vaxx_plus_cases_fl %>% 
  filter(date<="2021-11-01") %>% 
  summarise(sum(cases)) * 1-exp(-1/16) * 6

deaths_only_estimate = vaxx_plus_cases_fl %>% 
  filter(date<="2021-11-01") %>% 
  summarise(sum(deaths))



initial_values_vaccines = InitialValueContainer(S0 = 21477737-1e3-head(vaccines_dates$cases,1)-deaths_only_estimate, 
                                             E0 = 1e3,
                                             I0 = head(vaccines_dates$cases,1),
                                             R0 = deaths_only_estimate)
```

13. Reinfection 

```{r reinfection, echo=TRUE, eval=TRUE}

reinfection_model = ReinfectionModel("SEIR") # without reinfection rate

```

14. Distance (Non-Spatial) 

```{r distance, echo=TRUE, eval=TRUE}

distance_model = DistanceModel(list(matrix(0))) # considering as one state therefore initialising with empty matrix

```

15. Set up Weibull distribution/parameters

```{r}
# reference: https://github.com/grantbrown/COVID19-US/blob/master/Templates/default.template.mortality.R

# pick a Weibull distribution for the compartment membership time that most closely matches some reported values and use this to deduce mean latent and infectious period times
# attach an effective sample size to this distribution using gamma hyperpriors (choose gamma distributions with the chosen mean(s) but with different variances/effective sample sizes)
# this function maps the reported latent and infectious period times/ranges to selected quantiles of that compartment membership time


pickWeibullPars <- function(qdf){
  rslt <- optim(par = c(1,1), fn = function(par){
    sum((qweibull(p = qdf$q, shape = par[1], scale = par[2]) - qdf$x)^2) # estimates the parameters of weibull distribution given its 
                                                                            # (0.025 and 0.975) quantiles...squared difference
  })
  rslt$par
}

pickGammaHyperPars <- function(mean, ESS){
  b <- ESS/(mean+1)     # ESS = effective sample size
  a <- ESS - b          # b = event occur rate and a = number of events occurred
  c(a,b)
}
# below values using researched studies
latent_par_means <- pickWeibullPars(qdf=data.frame(q=c(0.025,0.5,0.975),
                                                   x=c(2,5,12)))  #picks means of shape and scale of latent period
# latent period: approximately 2-12 days with median 5 (mean ~ 6 days) 
# 95% LB = 2.188560, UB = 6.521399
infectious_par_means <- pickWeibullPars(qdf = data.frame(q=c(0.025,0.5,0.975),
                                                         x = c(8,13,22))) #picks means of shape and scale infectious period
# infectious period: approximately 10-24 days with median 14 (mean ~ 16 days)
# 95% LB = 4.412692, UB = 15.835367

weibull_transition_priors <- WeibullTransitionPriors(latent_shape_prior_alpha = pickGammaHyperPars(latent_par_means[1], 1000)[1],
                                            latent_shape_prior_beta = pickGammaHyperPars(latent_par_means[1], 1000)[2],
                                            latent_scale_prior_alpha = pickGammaHyperPars(latent_par_means[2], 1000)[1],
                                            latent_scale_prior_beta = pickGammaHyperPars(latent_par_means[2], 1000)[2],
                                            infectious_shape_prior_alpha = pickGammaHyperPars(infectious_par_means[1], 100)[1], #less certain about infectious period...in other words we have a larger range in which one can be infectious when compared to small latent period range so we use a smaller ESS
                                            infectious_shape_prior_beta = pickGammaHyperPars(infectious_par_means[1], 100)[2],
                                            infectious_scale_prior_alpha = pickGammaHyperPars(infectious_par_means[2], 100)[1],
                                            infectious_scale_prior_beta = pickGammaHyperPars(infectious_par_means[2], 100)[2])
```

```{r}

# https://github.com/grantbrown/ABSEIR/blob/master/R/transitionPriors.R

# alpha^lat ~ gamma(shape = 686.3788, rate = 313.6212) which maps probability of latent period shape being between 2.08 and 2.29
# take the min of these two values as it will provide the broadest range of possible values for the E to I transition!....with increasing shape values weibull distribution tends to get more narrow
# recall that scale = 1/rate

weibull_alpha_latent = qgamma(0.1, weibull_transition_priors$latent_shape_prior_alpha,
                        weibull_transition_priors$latent_shape_prior_beta) #minEIShape


# beta^lat ~ gamma(shape = 867.046, rate = 132.954) which maps probability of latent period shape being between 6.24 and 6.81
# take the max of these two values as it will provide the broadest range of possible values for the E to I transition!....with decreasing scale values weibull distribution tends to get more narrow

weibull_beta_latent = qgamma(0.9, weibull_transition_priors$latent_scale_prior_alpha,
                        weibull_transition_priors$latent_scale_prior_beta) #maxEIScale

# alpha^inf ~ gamma(shape = 81.5249, rate = 18.4751) which maps probability of infectious period shape being between 3.79 and 5.05

weibull_alpha_infectious = qgamma(0.1, weibull_transition_priors$infectious_shape_prior_alpha,
                        weibull_transition_priors$infectious_shape_prior_beta) #minIRShape

# beta^inf ~ gamma(shape = 94.06012, rate = 5.939876) which maps probability of infectious period shape being between 13.78 and 17.96
 
weibull_beta_infectious = qgamma(0.9, weibull_transition_priors$infectious_scale_prior_alpha,
                        weibull_transition_priors$infectious_scale_prior_beta) #maxIRScale

df_latent <- 
  tibble(
    x = seq(0,20,l=100)) %>%
      mutate(y = dweibull(x, shape=weibull_alpha_latent, scale = weibull_beta_latent))

df_infectious <- 
  tibble(
    x = seq(0,33,l=1000)) %>%
      mutate(y = dweibull(x, shape=weibull_alpha_infectious, scale = weibull_beta_infectious))

#pweibull(10, shape = weibull_alpha_latent, scale = weibull_beta_latent) # (prior) probability individual will transition from exposed to infectious within 10 days

#pweibull(14, shape = weibull_alpha_infectious, scale = weibull_beta_infectious) # (prior) probability individual will transition from infectious to removed within two weeks

weibull_beta_latent * gamma(1 + 1/weibull_alpha_latent) # mean latent period
weibull_beta_infectious * gamma(1 + 1/weibull_alpha_infectious) # mean infectious period

weibull_beta_latent*(ln(2))^(1/weibull_alpha_latent) # median latent period
weibull_beta_infectious*(ln(2))^(1/weibull_alpha_infectious) # median infectious period

qweibull(0.95,shape = weibull_alpha_latent, scale = weibull_beta_latent)
qweibull(0.95,shape = weibull_alpha_infectious, scale = weibull_beta_infectious)

#sqrt((scale^2) * (gamma(1 + 2/shape) - gamma(1 + 1/shape)^2)) # sd
```

```{r}
# reference: https://stackoverflow.com/questions/69121598/given-the-probability-find-y-for-gamma-distribution

# latent period

ggplot(df_latent,aes(x,y)) + 
  ggtitle("Latent Period (Weibull Distribution)") +
  xlab("Days") + ylab("Probability Density") +
  geom_function(fun = dweibull, args = list(shape = weibull_alpha_latent, scale = weibull_beta_latent))+
  geom_vline(xintercept = qweibull(0.95, shape = weibull_alpha_latent, scale = weibull_beta_latent), linetype = "dashed", col = "blue")+
  geom_vline(xintercept = qweibull(0.5, shape = weibull_alpha_latent, scale = weibull_beta_latent), linetype = "dashed", col = "darkorchid")+
  geom_vline(xintercept = weibull_beta_latent * gamma(1 + 1/weibull_alpha_latent), linetype = "solid", col = "red")+  
  theme_bw()+
  #scale_x_continuous(round(qweibull(0.95,shape = weibull_alpha_latent, scale = weibull_beta_latent),2))+
  geom_area(data = df_latent %>% filter(x <= qweibull(0.95,shape = weibull_alpha_latent, scale = weibull_beta_latent)),
            alpha = .7, fill = "bisque")+
  scale_y_continuous(expand = c(0,0))+
  annotate(geom = "text",x = 6,y =0.05,label = "95%",size = 8) 
```

```{r}
# infectious period

ggplot(df_infectious,aes(x,y)) + 
  ggtitle("Infectious Period (Weibull Distribution)") +
  xlab("Days") + ylab("Probability Density") +
  geom_function(fun = dweibull, args = list(shape = weibull_alpha_infectious, scale = weibull_beta_infectious))+
  geom_vline(xintercept = qweibull(0.95, shape = weibull_alpha_infectious, scale = weibull_beta_infectious), linetype = "dashed", col = "blue")+
  geom_vline(xintercept = qweibull(0.5, shape = weibull_alpha_infectious, scale = weibull_beta_infectious), linetype = "dashed", col = "darkorchid")+
  geom_vline(xintercept = weibull_beta_infectious * gamma(1 + 1/weibull_alpha_infectious), linetype = "solid", col = "red")+
  theme_bw()+
  #scale_x_continuous(breaks = round(qweibull(0.95,shape = weibull_alpha_infectious, scale = weibull_beta_infectious),2))+
  geom_area(data = df_infectious %>% filter(x <= qweibull(0.95,shape = weibull_alpha_infectious, scale = weibull_beta_infectious)),
            alpha = .7, fill = "bisque")+
  scale_y_continuous(expand = c(0,0))+
  annotate(geom = "text",x = 16.5,y =0.03,label = "95%",size = 8) 
```
16. Set up exponential distribution for transition priors

```{r}
exp_transition_priors = ExponentialTransitionPriors(p_ei = 1-exp(-1/6),    # cdf of exponential dist...dont have actual value of gamma so estimate 
                                                    p_ir= 1-exp(-1/16),    # using mean (period) = 1/gamma => gamma = 1/mean(period)
                                                    #......exp(rate parameter = 1/6, ie. mean = 6)
                                                    p_ei_ess = 1000,        # more informative as 1000 > 100
                                                    p_ir_ess = 100)
# 1-exp(-gamma) = p_ei is transition prob and 1/gamma is the mean period
# this gives a mean latent period of 6 days and a median of approximately 4.16 days
# mean infectious period of 16 days and a median of approximately 11.1 days


# use best three models for each differing timelines...one that gives closest estimate to provided mean periods = run with weibull for comparison
```

```{r}

df_explat <- 
  tibble(
    x = seq(0,25,l=100)) %>%
      mutate(y = dexp(x, rate = 1/6))

df_expinf <- 
  tibble(
    x = seq(0,50,l=1000)) %>%
      mutate(y = dexp(x, rate = 1/16))

# reference: https://stackoverflow.com/questions/69121598/given-the-probability-find-y-for-gamma-distribution

# latent period

ggplot(df_explat,aes(x,y)) + 
  ggtitle("Latent Period (Exponential Distribution)") +
  xlab("Days") + ylab("Probability Density") +
  geom_function(fun = dexp, args = list(rate=1/6))+
  geom_vline(xintercept = qexp(0.95, rate=1/6), linetype = "dashed", col = "blue")+
  geom_vline(xintercept = qexp(0.5, rate=1/6), linetype = "dashed", col = "darkorchid")+
  geom_vline(xintercept = 6, linetype = "solid", col = "red")+  
  theme_bw()+
  geom_area(data = df_explat %>% filter(x <= qexp(0.95,rate=1/6)),
            alpha = .7, fill = "bisque")+
  scale_y_continuous(expand = c(0,0))+
  annotate(geom = "text",x = 2,y =0.03,label = "95%",size = 8) 

# 95% persons go from E to I within 17.97439 days
# median of 4.16
# mean of 6
```

```{r}
ggplot(df_expinf,aes(x,y)) + 
  ggtitle("Infectious Period (Exponential Distribution)") +
  xlab("Days") + ylab("Probability Density") +
  geom_function(fun = dexp, args = list(rate=1/16))+
  geom_vline(xintercept = qexp(0.95, rate=1/16), linetype = "dashed", col = "blue")+
  geom_vline(xintercept = qexp(0.5, rate=1/16), linetype = "dashed", col = "darkorchid")+
  geom_vline(xintercept = 16, linetype = "solid", col = "red")+  
  theme_bw()+
  geom_area(data = df_expinf %>% filter(x <= qexp(0.95,rate=1/16)),
            alpha = .7, fill = "bisque")+
  scale_y_continuous(expand = c(0,0))+
  annotate(geom = "text",x = 6,y =0.02,label = "95%",size = 8) 

# 95% persons go from E to I within 47.93172 days
# median of 11.09035
# mean of 16
```


17. Set up sampling control

```{r sampling control, echo=TRUE, eval=TRUE}

# shrinkage: improves prediction because of the bias-variance tradeoff; a small increase in bias (the penalty) in exchange for a larger reduction in variance (the model is less sensitive to noise or correlation of predictors)
# shrinkage estimation deliberately increases the bias of the model in order to reduce variance and improve overall model performance, often at the cost of individual estimates
# less shrinkage = less bias but more variance

# from documentation: shrinkage defines the multiplicative constant by which the maximum distance between simulated and observed epidemics is shrunk between each iteration.....(simulated values shrunk closer towards observed values after each iteration)

# shrinkage x previous epsilon = current epsilon

sampling_control_SMC = SamplingControl(seed = 123123, 
                                    n_cores = 14,
                                    algorithm="Beaumont2009",
                                    list(batch_size = 2000,
                                         init_batch_size = 1000000,
                                         epochs = 1e6,
                                         max_batches = 250, 
                                         shrinkage = 0.99, # 1.5 bias for 0.9, higher for 0.999
                                         multivariate_perturbation=FALSE,
                                         keep_compartments = TRUE
                                    )
 )

sampling_control_basic = SamplingControl(seed = 123123, 
                                    n_cores = 14,
                                    algorithm="BasicABC",
                                    list(batch_size = 2000,
                                         init_batch_size = 1000000,
                                         epochs = 1e6,
                                         max_batches = 250,
                                         acceptance_fraction = 0.01,
                                         shrinkage = 0.99,
                                         multivariate_perturbation=FALSE,
                                         keep_compartments = TRUE
                                    )
 )

# algorithm="Beaumont2009" for SMC-ABC
```

18. Run models/sims

```{r runtime and summary}

#consider showing difference of weibull transition priors vs exponential transition priors
#get results for basic ABC for exp and weibull both SMC and basic


runtime1 = system.time(result1 <- SpatialSEIRModel(data_model,
                                                    exposure_model_1,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime2 = system.time(result2 <- SpatialSEIRModel(data_model,
                                                    exposure_model_2,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime3 = system.time(result3 <- SpatialSEIRModel(data_model,
                                                    exposure_model_3,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime3_weibull = system.time(result3_weibull <- SpatialSEIRModel(data_model,
                                                    exposure_model_3,
                                                    reinfection_model,
                                                    distance_model,
                                                   weibull_transition_priors,
                                                    #exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime3_exp_basic = system.time(result3_exp_basic <- SpatialSEIRModel(data_model,
                                                    exposure_model_3,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_basic,
                                                    samples = 100,
                                                    verbose = 2))
runtime3_weibull_basic = system.time(result3_weibull_basic <- SpatialSEIRModel(data_model,
                                                    exposure_model_3,
                                                    reinfection_model,
                                                    distance_model,
                                                   weibull_transition_priors,
                                                    #exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_basic,
                                                    samples = 100,
                                                    verbose = 2))

```


```{r}

runtime4 = system.time(result4 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_4,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100, # less samples, less variance
                                                    verbose = 2))
runtime5 = system.time(result5 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_5,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime6 = system.time(result6 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_6,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime7 = system.time(result7 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_7,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime8 = system.time(result8 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_8,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))

```

```{r}

runtime9 = system.time(result9 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_9,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime10 = system.time(result10 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_10,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime11 = system.time(result11 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_11,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime12 = system.time(result12 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_12,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime13 = system.time(result13 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_13,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
runtime14 = system.time(result14 <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_14,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
# Interpretation of Beta_SE coefficients: https://github.com/grantbrown/ABSEIR/issues/17

```

```{r}
runtime15 = system.time(result15 <- SpatialSEIRModel(data_model_vaccines,
                                                    exposure_model_15,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values_vaccines,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))



```


```{r}
comps <- compareModels(list(result2, result3, result3_weibull), n_samples = 1000, 
              batch_size = 2000)
print(comps)

# splines approach allows us to construct flexible models in the absence of structural information about the pandemic which would otherwise help inform the intensity process, such as finer spatiotemporal indexing (ie. between counties) and comprehensive data on public health efforts, among other things.....especially with florida as they never had any state mandated mask wearing protocols but this doesnt mean individuals didnt take part in mask wearing (which reduces exposure)

# If these (current eps) are dramatically different, this approach may produce misleading results.

# weibull under SMC is best

```

19. Get Bayes factor for model selection

```{r}
comps_1 <-compareModels(list(result4, result5, result6, result7, result8), n_samples = 1000, 
              batch_size = 2000)
print(comps_1)

# model 6 best
```

```{r}
comps_2 <- compareModels(list(result9, result10, result11, result12, result13, result14), n_samples = 1000, 
              batch_size = 2000)
print(comps_2)


# model 11 best
```


```{r}
simulations1 <- epidemic.simulations(result1, replicates = 50)
simulations2 <- epidemic.simulations(result2, replicates = 50)
simulations3 <- epidemic.simulations(result3, replicates = 50)
simulations3_weibull <- epidemic.simulations(result3_weibull, replicates = 50)
simulations3_exp_basic <- epidemic.simulations(result3_exp_basic, replicates = 50)
simulations3_weibull_basic <- epidemic.simulations(result3_weibull_basic, replicates = 50)



```

```{r}
simulations4 <- epidemic.simulations(result4, replicates = 50)
simulations5 <- epidemic.simulations(result5, replicates = 50)
simulations6 <- epidemic.simulations(result6, replicates = 50)
simulations7 <- epidemic.simulations(result7, replicates = 50)
simulations8 <- epidemic.simulations(result8, replicates = 50)

```

```{r}
simulations9 <- epidemic.simulations(result9, replicates = 50)
simulations10 <- epidemic.simulations(result10, replicates = 50)
simulations11 <- epidemic.simulations(result11, replicates = 50)
simulations12 <- epidemic.simulations(result12, replicates = 50)
simulations13 <- epidemic.simulations(result13, replicates = 50)
simulations14 <- epidemic.simulations(result14, replicates = 50)

```

```{r}
simulations15 <- epidemic.simulations(result15, replicates = 50)

```


```{r}
get_coverage_ei = function(simulations, true_params)  
{
  allSimulatedlatent = sapply(simulations$simulationResults, function(x){x$p_ei})
  
  lowerQuantile = apply(allSimulatedlatent, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedlatent, 1, mean)
  upperQuantile = apply(allSimulatedlatent, 1, quantile, probs = c(0.975))

    
  
  a = mean(lowerQuantile <= true_params & true_params <= upperQuantile ) 
  # the ratio of times the confidence intervals overlaps the true mean gives a coverage estimate

  
  b = mean(upperQuantile - lowerQuantile)
  
  c = bias_per(y = true_params, yhat = posteriorMean)
  # taking the average of all estimates subtracted from the true mean reveals bias estimate

  
  return(list(coverage=a, width=b, bias=c))

}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
get_coverage_ir = function(simulations, true_params)  
{
  allSimulatedinfectious = sapply(simulations$simulationResults, function(x){x$p_ir})
  
  lowerQuantile = apply(allSimulatedinfectious, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedinfectious, 1, mean)
  upperQuantile = apply(allSimulatedinfectious, 1, quantile, probs = c(0.975))

    
  
  a = mean(lowerQuantile <= true_params & true_params <= upperQuantile ) # should be column of quantiles
  
  b = mean(upperQuantile - lowerQuantile)
  
  c = bias_per(y = true_params, yhat = posteriorMean)
  
  return(list(coverage=a, width=b, bias=c))

}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
plotPosteriorPredictive_firstwave = function(simulations, main)  
{
  allSimulatedI_star = sapply(simulations$simulationResults, function(x){x$I_star})
  
  lowerQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedI_star, 1, mean)
  upperQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.975))
  
  
  plot(first_wave$cases, ylim = c(0, max(upperQuantile)),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  lines(upperQuantile, lty = 2, col = "blue")
  lines(lowerQuantile, lty = 2, col = "blue")
  lines(posteriorMean, lty = 1, col = "blue")
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed"), lty = c(1,2,0), 
         pch = c(NA,NA,1), col = c("blue", "blue", "black"), cex = 1)
}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
plotPosteriorPredictive_interventions = function(simulations, main)  
{
  allSimulatedI_star = sapply(simulations$simulationResults, function(x){x$I_star})
  
  lowerQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedI_star, 1, mean)
  upperQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.975))
  
  
  plot(firstandsecond_wave$cases, ylim = c(0, max(posteriorMean)*1.75),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  lines(upperQuantile, lty = 2, col = "blue")
  lines(lowerQuantile, lty = 2, col = "blue")
  lines(posteriorMean, lty = 1, col = "blue")
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed"), lty = c(1,2,0), 
         pch = c(NA,NA,1), col = c("blue", "blue", "black"), cex = 1)
}

```

```{r}
plotPosteriorPredictive_vaccines = function(simulations, main)
{
  allSimulatedI_star = sapply(simulations$simulationResults, function(x){x$I_star})
  
  lowerQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.025))
  posteriorMean = apply(allSimulatedI_star, 1, mean)
  upperQuantile = apply(allSimulatedI_star, 1, quantile, probs = c(0.975))
  
  
  plot(vaccines_dates$cases, ylim = c(0, max(vaccines_dates$cases)),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  lines(upperQuantile, lty = 2, col = "blue")
  lines(lowerQuantile, lty = 2, col = "blue")
  lines(posteriorMean, lty = 1, col = "blue")
  
  #legend("topleft", legend = c("Mean", "95% CI", "Observed"), lty = c(1,2,0), 
         #pch = c(NA,NA,1), col = c("blue", "blue", "black"), cex = 1)
}

```

```{r}
plotPosteriorPredictive_compare_t1 = function(m1, m2, m3, main)  
{
  allSimulatedI_star_m1 = sapply(m1$simulationResults, function(x){x$I_star})
  
  lowerQuantile_m1 = apply(allSimulatedI_star_m1, 1, quantile, probs = c(0.025))
  posteriorMean_m1 = apply(allSimulatedI_star_m1, 1, mean)
  upperQuantile_m1 = apply(allSimulatedI_star_m1, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_m2 = sapply(m2$simulationResults, function(x){x$I_star})
  
  lowerQuantile_m2= apply(allSimulatedI_star_m2, 1, quantile, probs = c(0.025))
  posteriorMean_m2 = apply(allSimulatedI_star_m2, 1, mean)
  upperQuantile_m2 = apply(allSimulatedI_star_m2, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_m3 = sapply(m3$simulationResults, function(x){x$I_star})
  
  lowerQuantile_m3 = apply(allSimulatedI_star_m3, 1, quantile, probs = c(0.025))
  posteriorMean_m3= apply(allSimulatedI_star_m3, 1, mean)
  upperQuantile_m3 = apply(allSimulatedI_star_m3, 1, quantile, probs = c(0.975))
  
  
  plot(first_wave$cases, ylim = c(0, max(posteriorMean_m1,posteriorMean_m2,
                                                  posteriorMean_m3)*1.75),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  
  lines(upperQuantile_m1, lty = 2, col = "chartreuse2")
  lines(lowerQuantile_m1, lty = 2, col = "chartreuse2")
  lines(posteriorMean_m1, lty = 1, col = "chartreuse2")
  
  lines(upperQuantile_m2, lty = 2, col = "red")
  lines(lowerQuantile_m2, lty = 2, col = "red")
  lines(posteriorMean_m2, lty = 1, col = "red")
  
  lines(upperQuantile_m3, lty = 2, col = "blue")
  lines(lowerQuantile_m3, lty = 2, col = "blue")
  lines(posteriorMean_m3, lty = 1, col = "blue")
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed", "Model 1", "Model 2",
                               "Model 3"), 
         lty = c(1,2,0,1,1,1), 
         pch = c(NA,NA,1,NA,NA,NA), col = c("black", "black", "black", "chartreuse2", "red", "blue"), cex = 1)
}

```

```{r}
plotPosteriorPredictive_I = function(m1, m2, main)  
{
  allSimulatedI_star_m1 = sapply(m1$simulationResults, function(x){x$I})
  
  lowerQuantile_m1 = apply(allSimulatedI_star_m1, 1, quantile, probs = c(0.025))
  posteriorMean_m1 = apply(allSimulatedI_star_m1, 1, mean)
  upperQuantile_m1 = apply(allSimulatedI_star_m1, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_m2 = sapply(m2$simulationResults, function(x){x$I_star})
  
  lowerQuantile_m2= apply(allSimulatedI_star_m2, 1, quantile, probs = c(0.025))
  posteriorMean_m2 = apply(allSimulatedI_star_m2, 1, mean)
  upperQuantile_m2 = apply(allSimulatedI_star_m2, 1, quantile, probs = c(0.975))
  
  
  plot(0:nrow(first_wave), ylim = c(0, max(posteriorMean_m1,posteriorMean_m2)),
       xlab = "Epidemic Day", ylab = "Infected Compartment (I)", main = main, type = "l")
  
  lines(upperQuantile_m1, lty = 2, col = "blue")
  lines(lowerQuantile_m1, lty = 2, col = "blue")
  lines(posteriorMean_m1, lty = 1, col = "blue")
  
  lines(upperQuantile_m2, lty = 2, col = "red")
  lines(lowerQuantile_m2, lty = 2, col = "red")
  lines(posteriorMean_m2, lty = 1, col = "red")
  
  
  legend("topleft", legend = c("Mean", "95% CI", "Exponential (SMC)", "Weibull (SMC)"), 
         lty = c(1,2,1,1), 
         pch = c(NA,NA,NA,NA), col = c("black", "black", "blue", "red"), cex = 1)
}

```

```{r}
plotPosteriorPredictive_compare_t1_alg = function(simulations_exp_SMC, simulations_wei_SMC, 
                                                  simulations_exp_basic, simulations_wei_basic, main)  
{
   allSimulatedI_star_exp_SMC = sapply(simulations_exp_SMC$simulationResults, function(x){x$I_star})
  
  lowerQuantile_exp_SMC = apply(allSimulatedI_star_exp_SMC, 1, quantile, probs = c(0.025))
  posteriorMean_exp_SMC = apply(allSimulatedI_star_exp_SMC, 1, mean)
  upperQuantile_exp_SMC = apply(allSimulatedI_star_exp_SMC, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_wei_SMC = sapply(simulations_wei_SMC$simulationResults, function(x){x$I_star})
  
  lowerQuantile_wei_SMC = apply(allSimulatedI_star_wei_SMC, 1, quantile, probs = c(0.025))
  posteriorMean_wei_SMC = apply(allSimulatedI_star_wei_SMC, 1, mean)
  upperQuantile_wei_SMC = apply(allSimulatedI_star_wei_SMC, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_exp_basic = sapply(simulations_exp_basic$simulationResults, function(x){x$I_star})
  
  lowerQuantile_exp_basic = apply(allSimulatedI_star_exp_basic, 1, quantile, probs = c(0.025))
  posteriorMean_exp_basic = apply(allSimulatedI_star_exp_basic, 1, mean)
  upperQuantile_exp_basic = apply(allSimulatedI_star_exp_basic, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_wei_basic = sapply(simulations_wei_basic$simulationResults, function(x){x$I_star})
  
  lowerQuantile_wei_basic = apply(allSimulatedI_star_wei_basic, 1, quantile, probs = c(0.025))
  posteriorMean_wei_basic = apply(allSimulatedI_star_wei_basic, 1, mean)
  upperQuantile_wei_basic = apply(allSimulatedI_star_wei_basic, 1, quantile, probs = c(0.975))
  
  
  plot(first_wave$cases, ylim = c(0, max(posteriorMean_exp_SMC,posteriorMean_wei_SMC,
                                                  posteriorMean_exp_basic,posteriorMean_wei_basic)*1.75),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  
  lines(upperQuantile_exp_SMC, lty = 2, col = "blue")
  lines(lowerQuantile_exp_SMC, lty = 2, col = "blue")
  lines(posteriorMean_exp_SMC, lty = 1, col = "blue")
  
  lines(upperQuantile_wei_SMC, lty = 2, col = "red")
  lines(lowerQuantile_wei_SMC, lty = 2, col = "red")
  lines(posteriorMean_wei_SMC, lty = 1, col = "red")
  
  lines(upperQuantile_exp_basic, lty = 2, col = "chartreuse2")
  lines(lowerQuantile_exp_basic, lty = 2, col = "chartreuse2")
  lines(posteriorMean_exp_basic, lty = 1, col = "chartreuse2")
  
  lines(upperQuantile_wei_basic, lty = 2, col = "darkgoldenrod1")
  lines(lowerQuantile_wei_basic, lty = 2, col = "darkgoldenrod1")
  lines(posteriorMean_wei_basic, lty = 1, col = "darkgoldenrod1")
  
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed", "Exponential (SMC)", "Weibull (SMC)",
                               "Exponential (Basic)", "Weibull (Basic)"), 
         lty = c(1,2,0,1,1,1,1), 
         pch = c(NA,NA,1,NA,NA,NA,NA), col = c("black", "black", "black", "blue", "red", "chartreuse2", "darkgoldenrod1"), cex = 1)
}

```

```{r}
plotPosteriorPredictive_compare_t2 = function(simulations_exp_SMC, simulations_wei_SMC, simulations_exp_basic, 
                                           simulations_wei_basic, main)  
{
  allSimulatedI_star_exp_SMC = sapply(simulations_exp_SMC$simulationResults, function(x){x$I_star})
  
  lowerQuantile_exp_SMC = apply(allSimulatedI_star_exp_SMC, 1, quantile, probs = c(0.025))
  posteriorMean_exp_SMC = apply(allSimulatedI_star_exp_SMC, 1, mean)
  upperQuantile_exp_SMC = apply(allSimulatedI_star_exp_SMC, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_wei_SMC = sapply(simulations_wei_SMC$simulationResults, function(x){x$I_star})
  
  lowerQuantile_wei_SMC = apply(allSimulatedI_star_wei_SMC, 1, quantile, probs = c(0.025))
  posteriorMean_wei_SMC = apply(allSimulatedI_star_wei_SMC, 1, mean)
  upperQuantile_wei_SMC = apply(allSimulatedI_star_wei_SMC, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_exp_basic = sapply(simulations_exp_basic$simulationResults, function(x){x$I_star})
  
  lowerQuantile_exp_basic = apply(allSimulatedI_star_exp_basic, 1, quantile, probs = c(0.025))
  posteriorMean_exp_basic = apply(allSimulatedI_star_exp_basic, 1, mean)
  upperQuantile_exp_basic = apply(allSimulatedI_star_exp_basic, 1, quantile, probs = c(0.975))
  
  allSimulatedI_star_wei_basic = sapply(simulations_wei_basic$simulationResults, function(x){x$I_star})
  
  lowerQuantile_wei_basic = apply(allSimulatedI_star_wei_basic, 1, quantile, probs = c(0.025))
  posteriorMean_wei_basic = apply(allSimulatedI_star_wei_basic, 1, mean)
  upperQuantile_wei_basic = apply(allSimulatedI_star_wei_basic, 1, quantile, probs = c(0.975))
  
  
  plot(firstandsecond_wave$cases, ylim = c(0, max(posteriorMean_exp_SMC,posteriorMean_wei_SMC,
                                                  posteriorMean_exp_basic,posteriorMean_wei_basic)*1.75),
       xlab = "Epidemic Day", ylab = "New Cases", main = main)
  
  lines(upperQuantile_exp_SMC, lty = 2, col = "blue")
  lines(lowerQuantile_exp_SMC, lty = 2, col = "blue")
  lines(posteriorMean_exp_SMC, lty = 1, col = "blue")
  
  lines(upperQuantile_wei_SMC, lty = 2, col = "red")
  lines(lowerQuantile_wei_SMC, lty = 2, col = "red")
  lines(posteriorMean_wei_SMC, lty = 1, col = "red")
  
  lines(upperQuantile_exp_basic, lty = 2, col = "chartreuse2")
  lines(lowerQuantile_exp_basic, lty = 2, col = "chartreuse2")
  lines(posteriorMean_exp_basic, lty = 1, col = "chartreuse2")
  
  lines(upperQuantile_wei_basic, lty = 2, col = "darkgoldenrod1")
  lines(lowerQuantile_wei_basic, lty = 2, col = "darkgoldenrod1")
  lines(posteriorMean_wei_basic, lty = 1, col = "darkgoldenrod1")
  
  
  legend("topleft", legend = c("Mean", "95% CI", "Observed", "Exponential (SMC)", "Weibull (SMC)",
                               "Exponential (Basic)", "Weibull (Basic)"), 
         lty = c(1,2,0,1,1,1,1), 
         pch = c(NA,NA,1,NA,NA,NA,NA), col = c("black", "black", "black", "blue", "red", "chartreuse2", "darkgoldenrod1"), cex = 1)
}

```



20. Plot posterior distributions and posterior predictive distributions

```{r}
plotPosteriorPredictive_firstwave(simulations1, "Model 1: Posterior Predictive Distribution")
plotPosteriorPredictive_firstwave(result1, "Model 1: Posterior Distribution")
```


```{r}
plotPosteriorPredictive_firstwave(simulations2, "Model 2: Posterior Predictive Distribution")
plotPosteriorPredictive_firstwave(result2, "Model 2: Posterior Distribution")
# interventions start at day 35
# assumes constant transmission until the introduction of control measures afterwhich transmission decays...hence why we see the model predict a peak around day 40-45 and decreases afterwards
```

```{r}
plotPosteriorPredictive_firstwave(simulations3, "Model 3: Posterior Predictive Distribution")
plotPosteriorPredictive_firstwave(result3, "Model 3: Posterior Distribution")
```

```{r}
plotPosteriorPredictive_interventions(simulations4, "Model 4: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result4, "Model 4: Posterior Distribution")

# two interventions
```
```{r}
plotPosteriorPredictive_interventions(simulations5, "Model 5: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result5, "Model 5: Posterior Distribution")

# two interventions plus time basis of 3
```
```{r}
plotPosteriorPredictive_interventions(simulations6, "Model 6: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result6, "Model 6: Posterior Distribution")

# two interventions plus time basis of 4
```
```{r}
plotPosteriorPredictive_interventions(simulations7, "Model 7: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result7, "Model 7: Posterior Distribution")

# two interventions plus time basis of 5
```
```{r}
plotPosteriorPredictive_interventions(simulations8, "Model 8: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result8, "Model 8: Posterior Distribution")

# two interventions plus time basis of 6
```

```{r}
plotPosteriorPredictive_interventions(simulations9, "Model 9: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result9, "Model 9: Posterior Distribution")

# two interventions and reopen
```

```{r}
plotPosteriorPredictive_interventions(simulations10, "Model 10: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result10, "Model 10: Posterior Distribution")

# two interventions, reopen and time basis of 3
```

```{r}
plotPosteriorPredictive_interventions(simulations11, "Model 11: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result11, "Model 11: Posterior Distribution")

# two interventions, reopen and time basis of 4
```

```{r}
plotPosteriorPredictive_interventions(simulations12, "Model 12: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result12, "Model 12: Posterior Distribution")

# two interventions, reopen and time basis of 5
```

```{r}
plotPosteriorPredictive_interventions(simulations13, "Model 13: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result13, "Model 13: Posterior Distribution")

# two interventions, reopen and time basis of 6
```

```{r}
plotPosteriorPredictive_interventions(simulations14, "Model 14: Posterior Predictive Distribution")
plotPosteriorPredictive_interventions(result14, "Model 14: Posterior Distribution")

# two interventions, reopen and trig temporal term
```

```{r}
plotPosteriorPredictive_vaccines(simulations15, "Model 15: Posterior Predictive Distribution")
plotPosteriorPredictive_vaccines(result15, "Model 15: Posterior Distribution")

# use vaccines for spatial case only
```

```{r}
plotPosteriorPredictive_compare_t1(simulations1,simulations2,simulations3,"Posterior Predictive Distribution: Model 1 vs Model 2 vs Model 3")
plotPosteriorPredictive_compare_t1(result1,result2,result3,"Posterior Distribution: Model 1 vs Model 2 vs Model 3")

# rate of infection predicted to be slower under the unconstrained growth model but infection increases exponentially...under intervention models the rate is faster but is slowed due to the interventions such that exponential growth is utlimately avoided
# surge of cases start developing around day 18...constant intensity assumed before day 16 afterwhich intensity decreases in a piecewise linear manner...hence decrease in exposure w
```

```{r}
plotPosteriorPredictive_I(simulations3, simulations3_weibull, "Posterior Predictive Distribution: Model 3")
```

```{r}
plotPosteriorPredictive_compare_t1_alg(simulations3,simulations3_weibull,simulations3_exp_basic,simulations3_weibull_basic,"Posterior Predictive Distribution: Model 3")
plotPosteriorPredictive_compare_t1_alg(result3,result3_weibull,result3_exp_basic, result3_weibull_basic,"Posterior Distribution: Model 3")

# rate of infection predicted to be slower under the unconstrained growth model but infection increases exponentially...under intervention models the rate is faster but is slowed due to the interventions such that exponential growth is ultimately avoided
# surge of cases start developing around day 18...constant intensity assumed before day 16 afterwhich intensity decreases in a piecewise linear manner...hence decrease in exposure and overall rate of spread such that rate of new infections slows down

```


21. Plot intensity predictions for models

```{r}
beta_idx_m1 <- grepl("Beta_SE", colnames(result1$param.samples)) # use to get beta estimates/samples
eta_m1 <- exposure_model_1$X %*% t(result1$param.samples[,beta_idx_m1]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m2 <- grepl("Beta_SE", colnames(result2$param.samples)) # use to get beta estimates/samples
eta_m2 <- exposure_model_2$X %*% t(result2$param.samples[,beta_idx_m2]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m3 <- grepl("Beta_SE", colnames(result3$param.samples)) # use to get beta estimates/samples
eta_m3 <- exposure_model_3$X %*% t(result3$param.samples[,beta_idx_m3]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m1, 1, mean), 
      type = 'l', 
      col="chartreuse2",
      main = 'Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day',
      ylim = c(min(eta_m1,eta_m2,eta_m3), max(eta_m1,eta_m2,eta_m3)*1.5))
 lines(apply(eta_m2, 1, mean), lty = 1, col = "red")
 lines(apply(eta_m3, 1, mean), lty = 1, col = "blue")
 
 legend("bottomleft", legend = c("Model 1", "Model 2",
                               "Model 3"), 
         lty = c(1,1,1,1), col = c("chartreuse2", "red", "blue"))


 
 # drives the I_star compartment
 # ignoring intervention info results in biased estimates of intensity parameters.....model 1 (no intervention) implies a less infectious epidemic process (mean -1.290) when compared to models 2 (mean 0.055) and 3 (mean 0.692).....model 3 is best because it includes two interventions and implies a more accurate (intense) infectious epidemic process
```

```{r}
beta_idx_m3_exp_basic  <- grepl("Beta_SE", colnames(result3_exp_basic$param.samples)) # use to get beta estimates/samples
eta_m3_exp_basic <- exposure_model_3$X %*% t(result3_exp_basic$param.samples[,beta_idx_m3_exp_basic]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m3_wei_basic  <- grepl("Beta_SE", colnames(result3_weibull_basic$param.samples)) # use to get beta estimates/samples
eta_m3_wei_basic <- exposure_model_3$X %*% t(result3_weibull_basic$param.samples[,beta_idx_m3_wei_basic]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m3_wei_SMC <- grepl("Beta_SE", colnames(result3_weibull$param.samples)) # use to get beta estimates/samples
eta_m3_wei_SMC <- exposure_model_3$X %*% t(result3_weibull$param.samples[,beta_idx_m3_wei_SMC]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m3, 1, mean), 
      type = 'l', 
      col="blue",
      main = 'Model 3 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day',
      ylim = c(min(eta_m3,eta_m3_exp_basic,eta_m3_wei_basic,eta_m3_wei_SMC), max(eta_m3,eta_m3_exp_basic,eta_m3_wei_basic,eta_m3_wei_SMC)*1.5))
 lines(apply(eta_m3_wei_SMC, 1, mean), lty = 1, col = "red")
 lines(apply(eta_m3_exp_basic, 1, mean), lty = 1, col = "chartreuse2")
  lines(apply(eta_m3_wei_basic, 1, mean), lty = 1, col = "darkgoldenrod1")

 
 
 
 legend("bottomleft", legend = c("Exponential (SMC)", "Weibull (SMC)",
                               "Exponential (Basic)", "Weibull (Basic)"), 
         lty = c(1,1,1,1), col = c("blue", "red", "chartreuse2", "darkgoldenrod1"))


 
 # weibull (SMC) predicts a much different intensity after the second intervention such that the gradient of the line is decreasing at a slower rate when compared to the other models; in particular, there is a more drastic shift when compared to the gradient in the previous timepoints.....hence the model predicts that the second intervention most probably resulted in an increase in epidemic intensity (when compared to the days before); either this or there was some other unaccounted factor which saw this increase
```

```{r}

beta_idx_m4 <- grepl("Beta_SE", colnames(result4$param.samples)) # use to get beta estimates/samples
eta_m4 <- exposure_model_4$X %*% t(result4$param.samples[,beta_idx_m4]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m4, 1, mean), 
      type = 'l', 
      main = 'Model 4 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day')
 
 # drives the I_star compartment
```

```{r}

beta_idx_m11 <- grepl("Beta_SE", colnames(result11$param.samples)) # use to get beta estimates/samples
eta_m11 <- exposure_model_11$X %*% t(result11$param.samples[,beta_idx_m11]) # get intensity matrix/time series (X(se) x Beta(se))
 
 plot(apply(eta_m11, 1, mean), 
      type = 'l', 
      main = 'Model 11 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day')
 
 # drives the I_star compartment
```

22. Get estimation summaries

```{r}
summary(result1)
```

```{r}
#allSimulatedI_m1 = sapply(simulations1$simulationResults, function(x){x$I})

#posteriorMean_m1 = apply(allSimulatedI_star, 1, mean)

#posteriorMean[5] .... I5 = 3
#posteriorMean[70] .... I70 = 1770
```


```{r}
summary(result2)
```

```{r}
summary(result3)

# effect of first intervention is stronger than that of the stay at home order in terms of flattening curve
# ideally cases should decrease after second intervention however they stay at a constant rate/number hence the position beta se estsimate for saho
# in fact this timeline overlaps with the reopen date/end of saho.....this is what is possibly (?) masking the effect of the saho such that the intensity appears to increase but actually this increas is due to the reopening
```

```{r}
summary(result3_weibull)

# effect of first intervention is stronger than that of the stay at home order in terms of flattening curve
# ideally cases should decrease after second intervention however they stay at a constant rate/number hence the position beta se estsimate for saho
# in fact this timeline overlaps with the reopen date/end of saho.....this is what is possibly (?) masking the effect of the saho such that the intensity appears to increase but actually this increas is due to the reopening
```

```{r}
summary(result3_weibull_basic)

# effect of first intervention is stronger than that of the stay at home order in terms of flattening curve
# ideally cases should decrease after second intervention however they stay at a constant rate/number hence the position beta se estsimate for saho
# in fact this timeline overlaps with the reopen date/end of saho.....this is what is possibly (?) masking the effect of the saho such that the intensity appears to increase but actually this increas is due to the reopening
```

```{r}
summary(result3_exp_basic)

# effect of first intervention is stronger than that of the stay at home order in terms of flattening curve
# ideally cases should decrease after second intervention however they stay at a constant rate/number hence the position beta se estsimate for saho
# in fact this timeline overlaps with the reopen date/end of saho.....this is what is possibly (?) masking the effect of the saho such that the intensity appears to increase but actually this increas is due to the reopening
```

```{r}
summary(result4)
```

```{r}
summary(result5)
```

```{r}
summary(result6)
```

```{r}
summary(result7)
```

```{r}
summary(result8)
```

```{r}
summary(result9)
```

```{r}
summary(result10)
```

```{r}
summary(result11)
```

```{r}
summary(result12)
```

```{r}
summary(result13)
```

```{r}
summary(result14)
```

```{r}
summary(result15)
```

23. Compare models to get best model

```{r}
comps_3 <- compareModels(list(result6, result11), n_samples = 1000, 
              batch_size = 2000)
print(comps_3)
```

24. Get coverage, width and bias for best model (latent and infectious periods)

```{r}
get_coverage_ei(simulations6, exp_transition_priors$p_ei) # underestimates latent period (minuscule)
```

```{r}
get_coverage_ei(simulations11, exp_transition_priors$p_ei) # underestimates latent period (minuscule)
```

```{r}
get_coverage_ir(simulations6, exp_transition_priors$p_ir)  # increased bias magnitude due to less confidence in terms of prior infectious period...slightly overestimates infectious period
```

```{r}
get_coverage_ir(simulations11, exp_transition_priors$p_ir)

# overestimates infectious period.....increased positive bias
```

25. Run best model with weibull distribution and get same as above for comparison

```{r}
runtime6_weibull = system.time(result6_weibull <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_6,
                                                    reinfection_model,
                                                    distance_model,
                                                   weibull_transition_priors,
                                                    #exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_SMC,
                                                    samples = 100,
                                                    verbose = 2))
```

```{r}
simulations6_weibull <- epidemic.simulations(result6_weibull, replicates = 50)

```


```{r}
summary(result6_weibull)
```
```{r}
comps_4 <- compareModels(list(result6, result6_weibull), n_samples = 1000, 
              batch_size = 2000)
print(comps_4)


# weibull better
```

```{r}
get_coverage_weibull = function(simulations, true_params, column)  
{
  sims <- as.data.frame(t(simulations$params[,column]))
  sims <- do.call("rbind", replicate(nrow(firstandsecond_wave), sims, simplify = FALSE))

  lowerQuantile = apply(sims, 1, quantile, probs = c(0.025))
  posteriorMean = apply(sims, 1, mean)
  upperQuantile = apply(sims, 1, quantile, probs = c(0.975))

    
  
  a = mean(lowerQuantile <= true_params & true_params <= upperQuantile ) # should be column of quantiles
  
  b = mean(upperQuantile - lowerQuantile)
  
  c = sum(mean(posteriorMean) - true_params)/sum(true_params) * 100
  
  return(list(coverage=a, width=b, bias=c))

}
 # use allSimulated function to get gamma IR and EI estimates for coverage and bias analysis
```

```{r}
get_coverage_weibull(simulations6_weibull,weibull_alpha_latent,"latent_shape")
```
```{r}
get_coverage_weibull(simulations6_weibull,weibull_beta_latent,"latent_scale")
```

```{r}
get_coverage_weibull(simulations6_weibull,weibull_alpha_infectious,"infectious_shape")
```

```{r}
get_coverage_weibull(simulations6_weibull,weibull_beta_infectious,"infectious_scale")
```

26. Run best model with Basic ABC algorithm plus exponential distribution and get same as above for comparison

```{r}
runtime6_exp_basic = system.time(result6_exp_basic <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_6,
                                                    reinfection_model,
                                                    distance_model,
                                                   #weibull_transition_priors,
                                                    exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_basic,
                                                    samples = 100,
                                                    verbose = 2))
```

```{r}
simulations6_exp_basic <- epidemic.simulations(result6_exp_basic, replicates = 50)

```


```{r}
summary(result6_exp_basic)
```

```{r}
get_coverage_ei(simulations6_exp_basic, exp_transition_priors$p_ei) # underestimates latent period (minuscule)
```

```{r}
get_coverage_ir(simulations6_exp_basic, exp_transition_priors$p_ir) # underestimates latent period (minuscule)
```

27. Run best model with Basic ABC algorithm plus weibull distribution and get same as above for comparison

```{r}
runtime6_weibull_basic = system.time(result6_weibull_basic <- SpatialSEIRModel(data_model_interventions,
                                                    exposure_model_6,
                                                    reinfection_model,
                                                    distance_model,
                                                   weibull_transition_priors,
                                                    #exp_transition_priors,
                                                    initial_values,
                                                    sampling_control_basic,
                                                    samples = 100,
                                                    verbose = 2))
```

```{r}
simulations6_weibull_basic <- epidemic.simulations(result6_weibull_basic, replicates = 50)

```

```{r}
plotPosteriorPredictive_compare_t2(simulations6,simulations6_weibull,simulations6_exp_basic,simulations6_weibull_basic,"Posterior Predictive Distribution: Model 6")
plotPosteriorPredictive_compare_t2(result6,result6_weibull,result6_exp_basic,result6_weibull_basic,"Posterior Distribution: Model 6")
```

```{r}

beta_idx_m6_expSMC <- grepl("Beta_SE", colnames(result6$param.samples)) # use to get beta estimates/samples
eta_m6_expSMC <- exposure_model_6$X %*% t(result6$param.samples[,beta_idx_m6_expSMC]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m6_weiSMC <- grepl("Beta_SE", colnames(result6_weibull$param.samples)) # use to get beta estimates/samples
eta_m6_weiSMC  <- exposure_model_6$X %*% t(result6_weibull$param.samples[,beta_idx_m6_weiSMC]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m6_expbasic <- grepl("Beta_SE", colnames(result6_exp_basic$param.samples)) # use to get beta estimates/samples
eta_m6_expbasic  <- exposure_model_6$X %*% t(result6_exp_basic$param.samples[,beta_idx_m6_expbasic]) # get intensity matrix/time series (X(se) x Beta(se))

beta_idx_m6_weibasic  <- grepl("Beta_SE", colnames(result6_weibull_basic$param.samples)) # use to get beta estimates/samples
eta_m6_weibasic   <- exposure_model_6$X %*% t(result6_weibull_basic$param.samples[,beta_idx_m6_weibasic]) # get intensity matrix/time series (X(se) x Beta(se))


 
 plot(apply(eta_m6_expSMC, 1, mean), 
      type = 'l', 
      col = "blue",
      main = 'Model 6 Intensity Prediction',
      ylab = 'η',
      xlab = 'Epidemic Day')
 lines(apply(eta_m6_weiSMC, 1, mean), lty = 1, col = "red")
 lines(apply(eta_m6_expbasic, 1, mean), lty = 1, col = "chartreuse2")
 lines(apply(eta_m6_weibasic, 1, mean), lty = 1, col = "darkgoldenrod1")
 
 legend("bottomleft", legend = c("Exponential (SMC)", "Weibull (SMC)",
                               "Exponential (Basic)", "Weibull (Basic)"), 
         lty = c(1,1,1,1), col = c("blue", "red", "chartreuse2", "darkgoldenrod1"))

 
 # drives the I_star compartment...there is some lag between rising intensity and actual cases as we account for latent period!
 # in the absence of splines, model assumes constant baseline intensity until intervention date afterwhich there is exponential decay...with splines (aids in improving estimation) we see that the starting intensity decreases and then increases sometime around implementation of the saho...meaning that there may be other factors not included in the model which are impacting intensity
```

```{r}
summary(result6_weibull_basic)
```

```{r}
get_coverage_weibull(simulations6_weibull_basic,weibull_alpha_latent,"latent_shape")
```
```{r}
get_coverage_weibull(simulations6_weibull_basic,weibull_beta_latent,"latent_scale")
```

```{r}
get_coverage_weibull(simulations6_weibull_basic,weibull_alpha_infectious,"infectious_shape")
```

```{r}
get_coverage_weibull(simulations6_weibull_basic,weibull_beta_infectious,"infectious_scale")
```

28. Finally get runtimes for all models

```{r}
timeMatrix = rbind(runtime1,runtime2, runtime3, runtime3_weibull, runtime3_exp_basic, runtime3_weibull_basic, runtime4, runtime5, runtime6, runtime7, runtime8, runtime9, runtime10, runtime11,
                   runtime12, runtime13, runtime14, runtime15, runtime6_weibull, runtime6_exp_basic, runtime6_weibull_basic)
rownames(timeMatrix) = paste("model", 1:21)
print(timeMatrix[,1:3])
# use in table with number of parameters and also number of timepoints
```













